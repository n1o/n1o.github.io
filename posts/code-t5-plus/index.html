<!doctype html><html lang=en><head><title>CodeT5 and CodeT5+ · Artificial Intelligence and Machine Learning Research
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Marek Barak"><meta name=description content="Abstract Link to heading In a previous post, T5 the Old New Thing, we briefly touched upon CodeT5 and CodeT5+. Now, we aim to dive deeper into these topics.
I have previously explored CodeBERT and GraphCodeBERT. These models, based on BERT and RoBERTa architectures, excel at code understanding and retrieval tasks. However, they fall short when it comes to code generation tasks. It&rsquo;s worth noting that these models share a common theme: they utilize unique pretraining objectives tailored specifically for source code."><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="CodeT5 and CodeT5+"><meta name=twitter:description content="Abstract Link to heading In a previous post, T5 the Old New Thing, we briefly touched upon CodeT5 and CodeT5+. Now, we aim to dive deeper into these topics.
I have previously explored CodeBERT and GraphCodeBERT. These models, based on BERT and RoBERTa architectures, excel at code understanding and retrieval tasks. However, they fall short when it comes to code generation tasks. It’s worth noting that these models share a common theme: they utilize unique pretraining objectives tailored specifically for source code."><meta property="og:url" content="https://n1o.github.io/posts/code-t5-plus/"><meta property="og:site_name" content="Artificial Intelligence and Machine Learning Research"><meta property="og:title" content="CodeT5 and CodeT5+"><meta property="og:description" content="Abstract Link to heading In a previous post, T5 the Old New Thing, we briefly touched upon CodeT5 and CodeT5+. Now, we aim to dive deeper into these topics.
I have previously explored CodeBERT and GraphCodeBERT. These models, based on BERT and RoBERTa architectures, excel at code understanding and retrieval tasks. However, they fall short when it comes to code generation tasks. It’s worth noting that these models share a common theme: they utilize unique pretraining objectives tailored specifically for source code."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-01T08:46:43+02:00"><meta property="article:modified_time" content="2024-06-01T08:46:43+02:00"><meta property="article:tag" content="NLP"><meta property="article:tag" content="T5"><meta property="article:tag" content="Transformers"><link rel=canonical href=https://n1o.github.io/posts/code-t5-plus/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e927f7340e309d76dcb8fda85f1531ae7341aa9cd0b7f3ab77885dae77b1a0a2.css integrity="sha256-6Sf3NA4wnXbcuP2oXxUxrnNBqpzQt/Ord4hdrnexoKI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://n1o.github.io/>Artificial Intelligence and Machine Learning Research
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Writing</a></li><li class=navigation-item><a class=navigation-link href=/awesome-t5/>Awesome T5</a></li><li class=navigation-item><a class=navigation-link href=/awesome-ssm/>Awesome SSM</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://n1o.github.io/posts/code-t5-plus/>CodeT5 and CodeT5+</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-06-01T08:46:43+02:00>June 1, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
14-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/nlp/>NLP</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/t5/>T5</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/transformers/>Transformers</a></span></div></div></header><div class=post-content><h1 id=abstract>Abstract
<a class=heading-link href=#abstract><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>In a previous post, <a href=/posts/t5-the-old-new-thing/>T5 the Old New Thing</a>, we briefly touched upon CodeT5 and CodeT5+. Now, we aim to dive deeper into these topics.</p><p>I have previously explored <a href=https://codebreakers.re/articles/detail/bert-codebert-and-graphcodebert/ class=external-link target=_blank rel=noopener>CodeBERT and GraphCodeBERT</a>. These models, based on <a href=https://arxiv.org/abs/1810.04805 class=external-link target=_blank rel=noopener>BERT</a> and <a href=https://arxiv.org/abs/1907.11692 class=external-link target=_blank rel=noopener>RoBERTa</a> architectures, excel at code understanding and retrieval tasks. However, they fall short when it comes to code generation tasks. It&rsquo;s worth noting that these models share a common theme: they utilize unique pretraining objectives tailored specifically for source code.</p><h1 id=codet5>CodeT5
<a class=heading-link href=#codet5><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Introduced by <a href=https://arxiv.org/abs/2109.00859 class=external-link target=_blank rel=noopener>Wang et al.(2021)</a>, CodeT5 aims to bridge the gap between Encoder-Only models like CodeBERT, which excel at code understanding but fall short at code generation, and Decoder-Only models like GPT, which are proficient at code generation but perform poorly at code understanding tasks. As a result, CodeT5 is a comprehensive Encoder-Decoder model, pretrained on a vast corpus of unimodal pure Source Code and bimodal Source Code and Natural Language pairs. It uses a variety of pretraining objectives, some of which are specifically designed for source code.</p><h2 id=intuition>Intuition
<a class=heading-link href=#intuition><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>CodeT5&rsquo;s implementation is based on the T5 model, a sequence-to-sequence model. Therefore, we formulate all our problems as sequence-to-sequence tasks.</p><p><img alt=T5 src=/images/codeT5Architecture.png></p><p>By pretraining on a large corpus of code, we can leverage developer-assigned identifiers such as comments, variable types and their names, function names, signatures, return types, and many more. To capture the semantics of these identifiers, CodeT5 introduces an identifier-aware pretraining objective. This trains the model to distinguish which tokens are identifiers and how to recover them when they are masked. This is beneficial for code understanding and generation tasks, as it allows the model to learn the alignment between code and comments, and to recover identifiers when they are masked.</p><h2 id=tokenization>Tokenization
<a class=heading-link href=#tokenization><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The tokenization of the input sequence is performed using a custom-trained Byte Pair Encoding (BPE) tokenizer. This subword tokenizer splits words into subwords and is used to build a vocabulary of 32k tokens. We also introduce several special tokens ([PAD], [CLS], [SEP], [MASK0], [MASK1], &mldr; [MASK99]) to represent the input sequence. It&rsquo;s worth noting that this differs from the original T5 model, which used a SentencePiece tokenizer. The reason is simple: our custom-trained BPE tokenizer performs better on source code, whereas the original T5 tokenizer was encoding common code tokens like [,],{,} as unknown tokens.</p><h2 id=inputoutput-representation>Input/Output representation
<a class=heading-link href=#inputoutput-representation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The input representation of CodeT5 consists of a sequence of tokens, which is a concatenation of Natural Language (NL) and Programming Language (PL) tokens.</p><p>$$x = ([CLS], w_1, \cdots, w_n, [SEP], c_1, \cdots, c_m, [SEP]) $$</p><ul><li>$[CLS]$ is a special token placed at the beginning of the sequence. Similar to BERT, this token represents the entire sequence and can be used later for classification or retrieval tasks.</li><li>$[SEP]$ is a special token that separates the NL and PL tokens</li><li>$n$ represents the number of NL word tokens.</li><li>$m$ represents the number of PL code tokens.</li></ul><h3 id=abstract-syntax-tree-ast>Abstract Syntax Tree (AST)
<a class=heading-link href=#abstract-syntax-tree-ast><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>To learn code-specific features, we utilize the AST of the source code. We extract node types for each node and introduce a sequence of binary labels $y {0,1}^m$ to represent whether a code segment $c_i$ is an identifier or not.</p><h2 id=pretraining>Pretraining
<a class=heading-link href=#pretraining><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For the corpus, we use the CodeSearchNet dataset and a collection of C/C# open-source Github repositories. The pretraining objectives we use are as follows:</p><ul><li>Masked Span Prediction</li><li>Identifier Tagging</li><li>Masked Identifier Prediction</li></ul><p>It&rsquo;s worth noting that Identifier Tagging and Masked Identifier Prediction utilize information from the AST, which is the source of their power.</p><p><img alt="CodeT5 pretraining" src=/images/code_t5_pretraining.png></p><h3 id=masked-span-prediction-msp>Masked Span Prediction (MSP)
<a class=heading-link href=#masked-span-prediction-msp><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This well-known pretraining objective, employed by T5, involves corrupting a span of tokens and requiring the decoder to recover the original tokens, including sentinel tokens. The corruption rate is 15%, and the span length is sampled from Uniform(1,5). We employ whole word masking to avoid partial masking.</p><h4 id=loss>Loss
<a class=heading-link href=#loss><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>$$ L_{MSP}(\theta) = \sum_{t=1}^k - \log P_{\theta}(x_t^{mask}| x^{\backslash mask}, x_{&lt;t}^{mask})$$</p><ul><li>$x^{\backslash mask}$ represents the masked input</li><li>$x^{mask}$ is the masked sentence that the decoder predicts</li><li>$k$ is the number of tokens in $x^{mask}$</li><li>$x^{mask}_{&lt;t}$ is the span sequence generated so far</li></ul><h3 id=identifier-tagging-it>Identifier Tagging (IT)
<a class=heading-link href=#identifier-tagging-it><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This pretraining objective trains the model to distinguish between identifiers and non-identifiers in the code, akin to syntax highlighting. This objective only activates the encoder and uses the contextual representation of the PL tokens right before they are passed to the decoder. We map these contextual representations to a sequence of probabilities. Unfortunately, the paper does not provide exact details on how this is done, nor does the <a href=https://github.com/salesforce/CodeT5/blob/e78a61a17f6dc2f3cbb968447d3e2d065b426e7b/CodeT5/models.py class=external-link target=_blank rel=noopener>source code</a>. My assumption is that they add an additional projection layer with some sort of normalization (like L2). The output of the projection layer will be a single scalar that is then passed through a sigmoid function, yielding the probability that the token is an identifier.</p><h4 id=loss-1>Loss
<a class=heading-link href=#loss-1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>$$ L_{IT}(\theta_e) = - \sum_{i=1}^m y_i \log p_i + (1 - y_i) \log (1 - p_i)$$</p><ul><li>$\theta_e$ represents the encoder parameters</li></ul><p>Again, the paper does not mention this, but I expect they may not even choose to send the output from the encoder to the decoder, as the decoder is not used in this task.</p><h3 id=masked-identifier-prediction-mip>Masked Identifier Prediction (MIP)
<a class=heading-link href=#masked-identifier-prediction-mip><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This pretraining objective can be viewed as a sort of de-obfuscation task and is based on the paper <a href=https://arxiv.org/abs/2102.07492 class=external-link target=_blank rel=noopener>DOBF</a>. The idea is that we mask specific identifiers in the code. The role of the decoder is then to produce the output key-value pairs, where the key is the masked identifier ([MASK0, MASK1, &mldr;]) and the value is the masked value.</p><h4 id=loss-2>Loss
<a class=heading-link href=#loss-2><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>$$L_{MIP}(\theta) = \sum_{j=1}^{|I|} - \log P_{\theta}(I_j| x^{\backslash I}, I_{&lt;j}) $$</p><ul><li>$x^{\backslash I}$ is the masked input</li></ul><h3 id=bimodal-generation>Bimodal Generation
<a class=heading-link href=#bimodal-generation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>During pretraining, the decoder only observes masked identifiers. However, we want our model to generate code from Natural Language (NL) or generate NL from code. In this step, we feed NL into the encoder and expect the decoder to generate the Programming Language (PL), and vice versa. Since we anticipate handling multiple programming languages, we prepend the input with a special token representing the programming language (, , etc.) or natural language ().</p><h1 id=fine-tuning>Fine-Tuning
<a class=heading-link href=#fine-tuning><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>We expect our model to handle the following tasks:</p><h2 id=code-summarization>Code Summarization
<a class=heading-link href=#code-summarization><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In this task, we expect an English summary of the code snippet. We evaluate the model on the BLEU-4 score, and it outperforms CodeBERT and PLBART, with the latter trained on a significantly larger dataset.</p><h2 id=code-generation>Code Generation
<a class=heading-link href=#code-generation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>We expect the model to generate code snippets from NL descriptions. We evaluate the model on CodeBLEU, which is more suitable for comparing code generation models as it takes into account language syntax, semantics, and structure. CodeT5 outperforms GPT-2 in this task.</p><h2 id=code-translation>Code Translation
<a class=heading-link href=#code-translation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The task involves translating one programming language into another. We evaluate the model on Exact Match, and CodeT5 manages to generate functions that are more readable and maintain the same functionality as the original code. This indicates the model&rsquo;s strong generalization capabilities. Here, the performance is better than that of GraphCodeBERT.</p><h2 id=code-refinement>Code Refinement
<a class=heading-link href=#code-refinement><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The task is to remove bugs. In this task, the performance is comparable to GraphCodeBERT, but it lags slightly behind.</p><h2 id=defect-detection>Defect Detection
<a class=heading-link href=#defect-detection><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The task is to detect if a code snippet is vulnerable or not. Performance-wise, we outperform all models, including GraphCodeBERT and PLBART, which were the state-of-the-art at the time the article was published.</p><h2 id=clonde-detection>Clonde Detection
<a class=heading-link href=#clonde-detection><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In this task, we measure the similarity of two code snippets, determining if they are the same or not. As with Defect Detection, CodeT5 achieved the current state-of-the-art score.</p><h2 id=remarks>Remarks
<a class=heading-link href=#remarks><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Performance-wise, we cannot really compare this model to current ones, because CodeT5 comes in two variants: Small (120M) and Base (220M). These sizes are dwarfed by the current 7B CodeLlama or even 22B CodeStral. Still CodeT5 is a strong model, and it serves as a base for many other models.</p><h1 id=codet>CodeT+
<a class=heading-link href=#codet><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Let&rsquo;s talk about CodeT5+ <a href=https://arxiv.org/abs/2305.07922 class=external-link target=_blank rel=noopener>Wang et al. (2023)</a>. This model, developed by the same research team, builds upon CodeT5 and scales its size up to 16B parameters. A few points are worth mentioning. Firstly, the authors are leaning more towards Decoder-only models, leading them to adopt a shallow encoder and a deep decoder architecture (the Decoder has more attention stacks than the Encoder). Secondly, they note that pretraining a Language Model from scratch is expensive and time-consuming. To address this, they bootstrap the encoder and the decoder from existing models and connect them with a cross-attention layer at the last layer of the decoder. During pretraining, they freeze the decoder and train only the encoder and the cross-attention layers. Lastly, they introduce a couple of new pretraining objectives like Text-Code Contrastive Learning and Text-Code Matching. Let&rsquo;s delve deeper into the model.</p><h2 id=model>Model
<a class=heading-link href=#model><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><img alt="CodeT5Plus Model" src=/images/code_t5_plus_model.png></p><p>It&rsquo;s not vastly different from the plain T5. Bootstrapping it from existing models is not unusual. What makes this model unique is its ability to work in different modes: encoder-only, decoder-only, or full encoder-decoder mode. Why is this important? Let&rsquo;s imagine that we need the encoder&rsquo;s embedding to perform a code similarity search; there&rsquo;s no need to use the decoder for that. Similarly, if we need to perform code completion, this task can be accomplished by the decoder alone. Running it in full encoder-decoder mode can be extremely useful for a Retrieval Augmented Generation (RAG) task, where the encoder&rsquo;s contextual representation is used for retrieval and the decoder is used for generation.</p><h3 id=bootstrapping>Bootstrapping
<a class=heading-link href=#bootstrapping><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>For the decoder, the authors choose <a href=https://arxiv.org/abs/2203.13474 class=external-link target=_blank rel=noopener>CodeGen-Mono</a> 350m and for the Decoder CodeGen-Mono 2B, 6B and 16B.</p><h2 id=pretraining-1>Pretraining
<a class=heading-link href=#pretraining-1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Given that CodeT5+ can operate in different modes, we have multiple stages of pretraining, each with different objectives and types of data (Uni-modal code only and Bi-modal code and natural language pairs).</p><h2 id=1-stage-uni-modal>1 Stage: Uni-modal
<a class=heading-link href=#1-stage-uni-modal><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In this stage, we leverage only code data. While the code may contain comments, we do not treat them as natural language-programming language pairs. The pretraining objectives are:</p><h3 id=span-denoising-objective>Span Denoising Objective
<a class=heading-link href=#span-denoising-objective><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This objective is similar to the Masked Span Prediction, where we randomly replace 15% of the tokens with [MASK] tokens in the encoder input, and we require the decoder to recover them by generating a combination of these spans. The difference is that we concatenate different code files into sequences and chunk them into fixed-length sequences. This task activates both the encoder and the decoder.</p><h3 id=causal-language-modeling>Causal Language Modeling
<a class=heading-link href=#causal-language-modeling><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This task is split into an encoder-decoder and a decoder-only task. Importantly, in both variants, we select a random pivot location, where all the tokens before the pivot are treated as the source sequence (context), and the tokens after the pivot are the target we aim to predict.</p><ol><li>Seq2Seq CausalLM variant: We prepend the source sequence with a special [CLM] token and feed it to the encoder. The rest of the sequence is the target for the decoder to generate. The pivot is somewhere between 10% and 90% of the sequence length.</li><li>Extreme Seq2Seq CausalLM variant: We prepend the source sequence with a special [CLM] token and require the decoder to generate the entire sequence. In this case, we train the decoder to operate independently from the encoder.</li></ol><h2 id=2-stage-bi-modal>2 Stage: Bi-modal
<a class=heading-link href=#2-stage-bi-modal><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In this stage, we have code-snippet and natural language pairs. This improves the alignment between code and natural language, enhancing cross-modal generation and understanding tasks. We have three pretraining objectives:</p><h3 id=text-code-contrastive-learning>Text-Code Contrastive Learning
<a class=heading-link href=#text-code-contrastive-learning><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This objective requires some patience to understand fully. The idea is that we want to learn representations of code such that code snippets that have similar functionality should have similar representations, and code snippets with different functionality should have different representations. The goal is to align the feature space of text and code representations by pulling together positive text-code pairs and pushing apart negative pairs. This objective only activates the encoder, which encodes a text or code snippet into a continuous representation. An [CLS] token is prepended to the input sequence and is used for the final embedding of the sequence. We pass the [CLS] representation through a linear layer and use L2 norm to map it to a 256-dimensional embedding.</p><h4 id=momentum-encoder>Momentum Encoder
<a class=heading-link href=#momentum-encoder><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>We&rsquo;ve already mentioned that we need positive and negative pairs. To get these, we use a <a href=https://arxiv.org/abs/1911.05722 class=external-link target=_blank rel=noopener>Momentum Encoder (MoCo)</a>. Technically, this is just another encoder that is identical to the encoder we already use. The goal of this encoder is to generate our negative samples by maintaining a queue of embeddings of samples from previous mini-batches. When there are new samples, it enqueues them, and when the queue is full, it dequeues the oldest samples. The parameters of the momentum encoder are updated by linear interpolation of the original encoder and the momentum encoder, ensuring the consistency of the representations across training steps.</p><p>The goal of the momentum encoder is to have access to negative samples (samples from previous batches), and since it evolves slowly (slower than the original encoder), it improves the stability of the training process.</p><h4 id=remarks-1>Remarks
<a class=heading-link href=#remarks-1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>While I&rsquo;m already familiar with negative sampling, typically, to construct the negative sample, we just took a random sample from the training dataset. Since the momentum encoder evolves slower than the original encoder, we force the embeddings to evolve slower as well, ensuring that the embeddings for the negative samples won&rsquo;t drastically change from one batch to another. This is a clever trick to stabilize the training process.</p><h3 id=text-code-matching>Text-Code Matching
<a class=heading-link href=#text-code-matching><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Unlike Text-Code Contrastive Learning, which only activates the encoder, Text-Code Matching is a decoder-only objective.</p><p>The goal is for the decoder to learn to determine if two snippets share the same semantics, thereby better aligning the text and code modalities. We prepend a task-specific [Match] token to the code input sequence to inform the decoder of the text-code matching functionality and append an [EOS] token to the end of the code input. We take the [EOS] representation at the last decoder layer as the text-code cross-modal alignment representation. This representation is passed through a linear layer and used for binary matching tasks, predicting if the text-code pair is a match or not. To get the negatives, we employ a <a href=https://arxiv.org/abs/1911.05722 class=external-link target=_blank rel=noopener>negative mining strategy</a>.</p><h4 id=remarks-2>Remarks
<a class=heading-link href=#remarks-2><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>Why is this a decoder-only task? It&rsquo;s hard to answer since the paper does not provide an explanation. Naturally, this task would be a fit for our encoder, but since we already use the encoder in Text-Code Contrastive Learning, we can use the decoder for this task. This forces both to learn kind of the same thing, but capturing different aspects of the problem. Also, the authors argue that the model can be used in a decoder-only setting, and by forcing the decoder to learn this task, it can improve its performance in this setting.</p><h3 id=text-code-causal-lm>Text-Code Causal LM
<a class=heading-link href=#text-code-causal-lm><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This objective activates both the encoder and decoder and focuses on code-to-text and text-to-code generation. If the input is text, we prepend a [CDec] token to the input sequence to the decoder, forcing the decoder to operate in code generation mode. If the input is code, we prepend a [TDec] token to the input sequence to the decoder, forcing the decoder to operate in text generation mode. This type of causal LM closes the gap between pretraining and fine-tuning for generative downstream tasks.</p><h2 id=instruction-tuning>Instruction Tuning
<a class=heading-link href=#instruction-tuning><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Since this is a post-ChatGPT paper, we are also interested in giving our model the ability to follow instructions. For this, we pretrain it using the <a href=https://github.com/sahil280114/codealpaca class=external-link target=_blank rel=noopener>CodeAlcapa</a> dataset, which is a dataset of code snippets and their corresponding instructions.</p><h2 id=performance>Performance
<a class=heading-link href=#performance><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Here, things get more complicated. The evaluation was on similar tasks as CodeT5, and in general, it exceeds the performance of CodeT5 when compared in equal settings (220M versions), and the improvements are significant. However, most comparisons were done to other Open Source Language Models like CodeBERT, GraphCodeBERT, PLBART, which are all smaller models. In pure code generation, CodeT5+ outperforms LLaMa and even StarCoder, thus making it the state-of-the-art model for code generation tasks. Unfortunately, the gap to proprietary models like ChatGPT is still large.</p><h3 id=remarks-3>Remarks
<a class=heading-link href=#remarks-3><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This whole bootstrapping from existing LLMs is nice, however, it makes a lot of comparisons more troublesome. I would really like to see some ablation studies on the different pretraining objectives and how they affect the model&rsquo;s performance.</p><h1 id=remarks-4>Remarks
<a class=heading-link href=#remarks-4><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>CodeT5+ offers a significant performance improvement over CodeT5. However, CodeT5 has seen wide adoption in the field of Cybersecurity and has been applied for <a href=https://arxiv.org/abs/2401.15468 class=external-link target=_blank rel=noopener>Automated Vulnerability Repair</a>. It also serves as the base for <a href=https://arxiv.org/abs/2301.01701 class=external-link target=_blank rel=noopener>BinT5</a> and <a href=https://ieeexplore.ieee.org/document/10298504 class=external-link target=_blank rel=noopener>HexT5</a>, which is not the case for CodeT5+ yet.</p><p>The lack of adoption of CodeT5+ may be due of its relative new age, or its permisive licencing for its 16B instruct version (Or maybe 16B is just too large).</p><p>One noteworthy aspect of CodeT5+ is its fine-tuning for the RaG task, which is a very interesting direction for future research.</p><p>Since I am not an native English speaker, I am using ChatGPT to improve my writing and fix my grammar mistakes you can read the <a href=https://github.com/n1o/n1o.github.io/blob/master/content/posts/code-t5-plus.md class=external-link target=_blank rel=noopener>Original here</a></p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//mbarak-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2020 -
2025
Marek Barak
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5WLCXX3LGJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5WLCXX3LGJ")}</script></body></html>