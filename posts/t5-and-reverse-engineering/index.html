<!doctype html><html lang=en><head><title>BinT5 and HexT5 or T5 and Binary Reverse Engineering · Data, Code and Breaking Stuff
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="n1o_c0rTx"><meta name=description content="Abstract Link to heading For a while now I have a new passion and that is binary reverse engineering and vulnerability exploitation. This interest has led me to create CodeBreakers a platform dedicated to applying machine learning to reverse engineering, vulnerability detection, exploitation, and other cybersecurity-related applications.
I found two notable research papers where T5 has been applied to reverse engineering are BinT5 and HexT5. Before we dive deep into the details of these papers, let&rsquo;s first explore the basics of reverse engineering."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="BinT5 and HexT5 or T5 and Binary Reverse Engineering"><meta name=twitter:description content="Abstract Link to heading For a while now I have a new passion and that is binary reverse engineering and vulnerability exploitation. This interest has led me to create CodeBreakers a platform dedicated to applying machine learning to reverse engineering, vulnerability detection, exploitation, and other cybersecurity-related applications.
I found two notable research papers where T5 has been applied to reverse engineering are BinT5 and HexT5. Before we dive deep into the details of these papers, let’s first explore the basics of reverse engineering."><meta property="og:url" content="https://n1o.github.io/posts/t5-and-reverse-engineering/"><meta property="og:site_name" content="Data, Code and Breaking Stuff"><meta property="og:title" content="BinT5 and HexT5 or T5 and Binary Reverse Engineering"><meta property="og:description" content="Abstract Link to heading For a while now I have a new passion and that is binary reverse engineering and vulnerability exploitation. This interest has led me to create CodeBreakers a platform dedicated to applying machine learning to reverse engineering, vulnerability detection, exploitation, and other cybersecurity-related applications.
I found two notable research papers where T5 has been applied to reverse engineering are BinT5 and HexT5. Before we dive deep into the details of these papers, let’s first explore the basics of reverse engineering."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-12T14:07:17+02:00"><meta property="article:modified_time" content="2024-06-12T14:07:17+02:00"><link rel=canonical href=https://n1o.github.io/posts/t5-and-reverse-engineering/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.127.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Data, Code and Breaking Stuff
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/awesome-t5/>Awesome T5</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://n1o.github.io/posts/t5-and-reverse-engineering/>BinT5 and HexT5 or T5 and Binary Reverse Engineering</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2024-06-12T14:07:17+02:00>June 12, 2024
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
14-minute read</span></div></div></header><div class=post-content><h1 id=abstract>Abstract
<a class=heading-link href=#abstract><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>For a while now I have a new passion and that is binary reverse engineering and vulnerability exploitation. This interest has led me to create <a href=https://codebreakers.re>CodeBreakers</a>
a platform dedicated to applying machine learning to reverse engineering, vulnerability detection, exploitation, and other cybersecurity-related applications.</p><p>I found two notable research papers where <a href=/posts/t5-the-old-new-thing/>T5</a> has been applied to reverse engineering are <a href=https://arxiv.org/abs/2301.01701>BinT5</a> and <a href=https://www.semanticscholar.org/paper/HexT5%3A-Unified-Pre-Training-for-Stripped-Binary-Xiong-Chen/04c3fccfe01f42afe18dcdb027385f350ab3c9d1>HexT5</a>. Before we dive deep into the details of these papers, let&rsquo;s first explore the basics of reverse engineering.</p><h2 id=reverse-engineering>Reverse Engineering
<a class=heading-link href=#reverse-engineering><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To understand reverse engineering, we must first understand compilation. Compilation is the process of translating a high-level programming language, such as C (yes, C is considered a high-level programming language), into machine code. Machine code is a format that your CPU can directly execute. The actual execution of machine code is a bit more complex, as an instruction like &ldquo;add&rdquo; can be further broken down into micro-code instructions. Instructions can be executed out of order, and with speculative execution, things can quickly become complicated, leaving room for errors and security vulnerabilities.</p><p>To keep things simple let&rsquo;s continue with machine code. Machine code is essentially a sequence of bytes. These bytes can represent instructions or data (the concept of &ldquo;code is data, data is code&rdquo; is a fundamental idea of Von Neumann&rsquo;s architecture). These bytes can, without loss of generality, be reconstructed back into assembly code. Assembly code is a human-readable representation of machine code. However, it&rsquo;s important to note that being human-readable does not necessarily mean it is easy to understand.</p><p>To give you an example of the following <code>simple_main.c</code> code:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;stdio.h&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main(<span style=color:#fff;font-weight:700>int</span> argc, <span style=color:#fff;font-weight:700>char</span> <span style=color:#fff;font-weight:700>const</span> *argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (argc &gt; <span style=color:#ff0;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#0ff;font-weight:700>&#34;More than one argument&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#0ff;font-weight:700>&#34;Hello, World!</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Compiled with GCC 11.4.0</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>gcc simple_main.c -o simple_main.so -no-pie -fno-stack-protector
</span></span></code></pre></div><p><strong>Please never ever enable those 2 flags above in production code, i just want to keep the assembly as simple as possible.</strong></p><p>We get <a href=https://raw.githubusercontent.com/n1o/n1o.github.io/master/examples/decompiled_simple_main.txt>this</a>, it ain&rsquo;t pretty, and it might contain more information than we asked for. However, it remains manageable, and in a reasonable timeframe, even an less experienced reverse engineer can extract the corresponding assembly for our main function::</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>0000000000401156 &lt;main&gt;:
</span></span><span style=display:flex><span>  401156:	f3 0f 1e fa          	endbr64 
</span></span><span style=display:flex><span>  40115a:	55                   	push   rbp
</span></span><span style=display:flex><span>  40115b:	48 89 e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>  40115e:	48 83 ec 10          	sub    rsp,0x10
</span></span><span style=display:flex><span>  401162:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
</span></span><span style=display:flex><span>  401165:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
</span></span><span style=display:flex><span>  401169:	83 7d fc 01          	cmp    DWORD PTR [rbp-0x4],0x1
</span></span><span style=display:flex><span>  40116d:	7e 14                	jle    401183 &lt;main+0x2d&gt;
</span></span><span style=display:flex><span>  40116f:	48 8d 05 8e 0e 00 00 	lea    rax,[rip+0xe8e]        # 402004 &lt;_IO_stdin_used+0x4&gt;
</span></span><span style=display:flex><span>  401176:	48 89 c7             	mov    rdi,rax
</span></span><span style=display:flex><span>  401179:	b8 00 00 00 00       	mov    eax,0x0
</span></span><span style=display:flex><span>  40117e:	e8 dd fe ff ff       	call   401060 &lt;printf@plt&gt;
</span></span><span style=display:flex><span>  401183:	48 8d 05 91 0e 00 00 	lea    rax,[rip+0xe91]        # 40201b &lt;_IO_stdin_used+0x1b&gt;
</span></span><span style=display:flex><span>  40118a:	48 89 c7             	mov    rdi,rax
</span></span><span style=display:flex><span>  40118d:	e8 be fe ff ff       	call   401050 &lt;puts@plt&gt;
</span></span><span style=display:flex><span>  401192:	b8 00 00 00 00       	mov    eax,0x0
</span></span><span style=display:flex><span>  401197:	c9                   	leave  
</span></span><span style=display:flex><span>  401198:	c3                   	ret    
</span></span></code></pre></div><p>The first column represents the memory address where the instruction is stored, the second column contains the opcodes, and the third column provides a human-readable representation of the opcode, supplemented with some comments. In the actual code, we observe some function calls, memory manipulation, and conditional jumps. Anyone with a basic understanding of calling conventions and assembly could reasonably comprehend what&rsquo;s happening.</p><p>Let&rsquo;s dive deeper and invoke the <code>strip</code> command to obtain <a href=https://raw.githubusercontent.com/n1o/n1o.github.io/master/examples/decompiled_striped_simple_main.txt>this beauty</a>. Stripping significantly complicates matters as there is no main function at all. Fortunately, we have access to the unstripped version (and we added the <code>-no-pie</code> flag to GCC), so our main function remains at <code>0x401156</code>. However, a pattern emerges: stripping the binary results in the loss of substantial information, such as function symbols and their boundaries. Most commercial software is stripped, and it&rsquo;s safe to assume that most malware is stripped as well.</p><p>I hope I&rsquo;ve managed to convince you that reverse engineering is challenging in its own right, and stripping binaries only amplifies this difficulty. When we introduce various source code obfuscations, we find ourselves facing a task that is nearly impossible.</p><h1 id=bint5>BinT5
<a class=heading-link href=#bint5><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Builds upon CodeT5 Base (220m) and fine-tunes it to perform reverse engineering, specifically to generate natural language summaries for binary functions. Why summaries? It&rsquo;s important to remember that compilation is not a one-to-one function, making the recovery of actual source code an impossible task. However, providing a high-level overview of a function&rsquo;s behavior gives the reverse engineer a good starting point, indicating where to focus and what to expect.</p><h2 id=input-data>Input Data
<a class=heading-link href=#input-data><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The authors note the absence of a reference dataset for reverse engineering tasks, leading them to create their own dataset. Named Capybara, it contains 214k decompiled C binaries for projects built for Ubuntu using Travis CI, compiled with GCC using the following optimization flags: -O0, -O1, -O2, -O3. These binaries are then stripped. One of the significant downsides of C projects is the lack of a standard single documentation format. To address this, the authors apply various heuristics to provide documentation for the functions.</p><p>The actual input of the model is not the assembly code, but the decompiled pseudo C code. The authors use <a href=https://www.ghidra-sre.org/>Ghidra</a> to generate pseudo C code. The choice of pseudo C over assembly is due to its greater readability and superior performance in experiments. Since CodeT5 was pretrained on C source code, and there is a substantial similarity between C source code and pseudo C code (it&rsquo;s referred to as pseudo C code because it doesn&rsquo;t have to be compilable), making it safe to assume that it will work well.</p><h3 id=demistriped-functions>Demistriped Functions
<a class=heading-link href=#demistriped-functions><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>By leveraging Ghidra, we can lift assembly code to pseudo C code. However, in stripped binaries, functions can be inlined, or <code>CALL</code> instructions can be replaced by <code>JUMP</code> instructions. The actual recovery of function boundaries is a separate research topic. Due to these imperfections, the authors introduce demistriped functions. These are functions lifted from binaries that are not stripped using <code>strip</code> command, but the identifiers like function names or variable names are manually removed.</p><h4 id=remarks>Remarks
<a class=heading-link href=#remarks><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>This scenario seems highly unrealistic, potentially limiting its applicability in real-world situations.</p><h2 id=performance>Performance
<a class=heading-link href=#performance><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The authors compare BinT5 to <a href=https://codebreakers.re/articles/detail/bert-codebert-and-graphcodebert/>GraphCodeBERT</a> and <a href=https://arxiv.org/abs/2112.02043>PolyGlotCodeBERT</a>, both fine-tuned on the Capybara dataset. On the BLEU-4 metric, BinT5 scores 3 to 5 points higher than the aforementioned models.</p><p>However, the model significantly struggles with stripped binaries. This struggle stems partly from inherent flaws in the decompilation process, particularly with inlined functions where the decompiler cannot recover the function boundaries.</p><p>In the case of demi-striped functions, the model performs significantly better. However, this is not a real-world scenario, which limits the model&rsquo;s usefulness.</p><h3 id=ablevation>Ablevation
<a class=heading-link href=#ablevation><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><h4 id=duplicates>Duplicates
<a class=heading-link href=#duplicates><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>The Capybara dataset contains some level of duplicates, which is natural since different projects tend to rely on shared libraries. By removing duplicates (or near duplicates) from the dataset, the model loses a lot of its performance on Exact Match. However, based on human evaluation, the summaries remain reasonable.</p><h4 id=source-code-comments-vs-function-names>Source Code Comments vs Function Names
<a class=heading-link href=#source-code-comments-vs-function-names><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>From a performance perspective, having comments in the code seems less important than actual identifiers, with function names contributing the most. However, in stripped binaries, we do not have function names.</p><h3 id=data-leakage>Data Leakage
<a class=heading-link href=#data-leakage><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>There are a few concerns about data leakage from CodeT5. CodeT5 was pretrained on a dataset containing C/C# code. Unfortunately, the dataset is not public, making it difficult to assess if the foundational model was pretrained on source code that is similar (or the same) as that used in BinT5. The authors claim that the data leakage is minimal since the performance of the model is comparable to fine-tuned GraphCodeBERT and PolyGlotCodeBERT (which were not pretrained on any C code) on the Capybara dataset.</p><h2 id=remarks-to-bint5>Remarks to BinT5
<a class=heading-link href=#remarks-to-bint5><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>I would like to applaud BinT5 as it represents the first attempt to apply T5 (or an LLM) to the reverse engineering of stripped binaries. However, the results are not particularly promising. The model performs well, but only in a very specific scenario (demi-striped), which is unlikely to occur in the real world.</p><p>In my personal opinion, the authors missed the main point of T5. They did not introduce any new pretraining objectives that would help the model better understand the binary code. Fortunately, we have HexT5 as an alternative.</p><h1 id=hext5>HexT5
<a class=heading-link href=#hext5><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>HexT5 picks up where BinT5 left off, introducing several pretraining objectives designed to enhance the model&rsquo;s understanding of binary code. The authors recognize that existing reverse engineering methods tend to focus narrowly on single tasks such as function name recovery, variable name recovery, binary code summarization, or binary function similarity detection. With HexT5, the authors aim to tackle all these tasks simultaneously, asserting that models trained on multiple objectives tend to outperform those trained on a single task. Additionally, they work with binaries compiled for different architectures (<code>x86, x86_64, arm32, arm64</code>), different compiler flags (<code>-O0, -O1, -O2, -O3</code>), and four compilers: clang-7.0, clang-9.0, gcc-7.2.0, gcc-8.3.0.</p><p>Like BinT5, HexT5 builds on top of T5 Base (220m).</p><h2 id=input-data-1>Input Data
<a class=heading-link href=#input-data-1><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>As with BinT5, HexT5 doesn&rsquo;t directly leverage binary code (assembly), but first decompiles it to pseudo C. However, in this case, <a href=https://hex-rays.com/ida-pro/>Hex-Rays</a> is used instead of Ghidra. Hex-Rays is a commercial (and expensive) product with performance that is arguably superior to Ghidra.</p><p>The source for the binaries is <a href=https://www.gnu.org/software/binutils/>GNU Binutils</a>, and the data is partitioned in a cross-project or cross-binary manner.</p><ol><li>Cross Project: A binary, for example, <code>ls</code> or <code>cat</code>, will be located in either the training or test set, including all the functions from that binary, compiled with different compiler flags, different compilers, and different architectures.</li><li>Cross Binary: This approach splits each binary into a set of functions, with each function being in either the training or test set. If a function is in the training set, then all its versions (compiled with different compiler flags, different compilers, and different architectures) are in the training set as well.</li></ol><h3 id=remarks-1>Remarks
<a class=heading-link href=#remarks-1><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Cross Project partitioning mirrors real-world scenarios, as it&rsquo;s unlikely that a reverse engineer will have access to some parts of the binary but not others. However, this is somewhat misleading, as binaries often share libraries and third-party code. Unfortunately, Cross Project partitioning performs worse than Cross Binary partitioning.</p><h3 id=dwarf>DWARF
<a class=heading-link href=#dwarf><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The authors utilize <a href=https://dwarfstd.org/>DWARF</a>, a debugging format used to map binary code to source code, as a bridge between the two. They extract symbols from the DWARF information and map them to the decompiled pseudo C code using their addresses. This allows for the recovery of variable names, function names, and other identifiers. However, in stripped binaries, the biggest challenge remains the detection of function boundaries. Unfortunately , this paper does not address this issue, limiting the model&rsquo;s usefulness in real-world scenarios.</p><h3 id=normalization>Normalization
<a class=heading-link href=#normalization><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>In stripped binaries, variable and function names often lack meaning. To address this, we replace them with special tokens. For variables, we use tokens &ldquo;&lt;VAR>, &lt;VAR2>, &mldr;, &lt;VAR100>&rdquo;. For the functions we want to reverse engineer, we reserve the token &ldquo;&lt;FUNC>&rdquo;. For all functions called from within, we use &ldquo;&lt;FUNC1>, &lt;FUNC2>, &mldr;, &lt;FUNC50>&rdquo;. Comments inside pseudo code, generated by the decompiler, bear no meaning and are therefore deleted. There is one edge case: variables that lack any meaningful name. In this case, we replace these variables with &ldquo;&lt;UKN>&rdquo; instead of &ldquo;&lt;VAR&mldr;>&rdquo;.</p><h2 id=pretraining-objectives>Pretraining Objectives
<a class=heading-link href=#pretraining-objectives><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Before we explore the pretraining objectives, let&rsquo;s revisit the model&rsquo;s goal. We want it to recover variable names, function names, summarize binary code, and detect binary code similarity. All these tasks can be viewed as a function that takes a programming language (in our case, pseudo C) and produces natural language, with binary code similarity detection being slightly different.</p><p>Why is this important? Most current LLMs aim to provide a conversational agent-like experience. HexT5 does not attempt to do this, eliminating the need for a Natural Language to Programming Language alignment objective. While this inability to prompt the model makes it more constrained, it allows the model to focus more on the task at hand.</p><p>HexT5&rsquo;s core consists of four pretraining objectives: Masked Span Prediction, Source Identifier Prediction, Bimodal Single Generation, and Contrastive Learning.</p><h3 id=masked-span-prediction>Masked Span Prediction
<a class=heading-link href=#masked-span-prediction><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This is essentially the same as in CodeT5. We take chunks of the input, mask them, and expect the model to recover the masked tokens. This objective aids in aligning pseudo code and comments.</p><p><img alt=MSP src=/images/hext5_masked_identifier_pred.png></p><h3 id=source-identifier-prediction-sip>Source Identifier Prediction (SIP)
<a class=heading-link href=#source-identifier-prediction-sip><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This objective, inspired by <a href=https://arxiv.org/abs/2102.07492>DOBF</a>, aims to teach the model deobfuscation. This means we attempt to recover the obfuscated variable names and function names. In our case, we try to predict the values hidden behind &ldquo;&lt;FUNC>, &lt;FUNC..>&rdquo; and &ldquo;&lt;VAR>&rdquo; tokens.</p><p><img alt=SIP src=/images/hext5_source_identifier_prediction.png></p><h3 id=bimodal-single-generation>Bimodal Single Generation
<a class=heading-link href=#bimodal-single-generation><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Goal of the objective is to align the programming language to natural language generation. Here we feed the whole Pseudo C code to the model and we want it to generate a natural language summary of the code. From the models perspective this objective is the same as SIP, to distinguish between the two objectives the authors add a hard prompt token &ldquo;summarize&rdquo; before the Pseudo C code (for SIP the prompt token is &ldquo;identifier_prediction&rdquo;).</p><p><img alt=BSG src=/images/hext5_bimodal_single_gen.png></p><h3 id=contrastive-learning>Contrastive Learning
<a class=heading-link href=#contrastive-learning><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The concept behind contrastive learning is to bring the contextual representations of similar functions closer together and push the representations of dissimilar functions further apart. We&rsquo;ve already seen this in <a href=/posts/code-t5-plus/>CodeT5+</a>. However, in the case of HexT5, we don&rsquo;t employ a Momentum Encoder. Instead, we use the remaining samples from a given mini-batch as negative samples, and for the positive samples, we use the same function but compiled with different compiler flags, different compilers, and/or different architectures.</p><p>One thing not explicitly stated in the paper is whether, if a given function is selected to be in a mini-batch, all the versions of that function are also in the mini-batch. I expect that this is the case.</p><p>Contrastive Learning is a sequence-level objective. This means we take a Pseudo C code snippet, pass it through the encoder part of the model, which yields a contextual representation for each token. To actually get the embedding, we average these contextual representations. We take this representation and pass it into the contrastive learning objective:</p><p>$$ L_{CL} = -\log \frac{e^{sim}(V,V^+)/\tau}{\sum_{j\in B} e^{sim (V,V_j^-)/\tau}} $$</p><ul><li>$sim$ is the similarity function, in our case cosine similarity</li><li>$V^+$ are the positive samples</li><li>$V^{-}$ are the negative samples, there is an additional way to sample the negatives, we can apply an random dropout mas to V_j, however I find this approach more confusing</li></ul><p><img alt=CL src=/images/hext5_contrastive_obj.png></p><h2 id=performance-1>Performance
<a class=heading-link href=#performance-1><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To cut a long story short, HexT5 has set the state-of-the-art in Binary Code Summarization, Variable Name Recovery, Function Name Recovery, and Binary Code Similarity Search. Interestingly, in Binary Code Summarization, they also benchmarked it against <a href=https://github.com/JusticeRage/Gepetto>Gepetto</a>. Gepetto is an Ida-Pro plugin that leverages OpenAI&rsquo;s Chat-GPT to generate summaries for binary functions.</p><h1 id=remarks-2>Remarks
<a class=heading-link href=#remarks-2><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><h2 id=function-boundaries>Function Boundaries
<a class=heading-link href=#function-boundaries><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Both models have some obvious downsides. The detection of function boundaries is a significant problem and without a solution, the models are not particularly useful in real-world scenarios.</p><h2 id=data-leakage-1>Data Leakage
<a class=heading-link href=#data-leakage-1><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In my personal opinion, data leakage is a serious concern. Let&rsquo;s consider a paper from <a href=https://arxiv.org/abs/2404.09836v1>Shang et. al 2024</a>, a newer study applying LLMs like GPT-4 and CodeLlama 7B for reverse engineering. They state that these autoregressive causal models perform much better than BinT5 or HexT5 (for HexT5, the reported scores are vastly different between the papers). These large causal foundational models have the capacity to memorize the training data, and since the training data is not public (for CodeLlama, we know it was pretrained on an additional 500B tokens or 864GB of source code, GPT-4 is unknown but due to Github Copilot&rsquo;s Codex, we can assume it saw an incredible amount of source code, not just open source).</p><p>It is hard limit the amount of data leakage, especially if we use Pseudo C code, which may be in many cases be very similar to the original source code. Because of this I would like to see and focus my personal research on techniques that either work with the binary code directly or they choose a different intermediate representation that is not so similar to the original source code.</p><h1 id=disclaimer>Disclaimer
<a class=heading-link href=#disclaimer><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Since I am not an english native speaker, I use ChatGPT to help me with the text (Formatting, Spelling, etc). However I did write every single word in this blog post, If you are interested you can check the the original text <a href=https://github.com/n1o/n1o.github.io/blob/master/content/posts/t5-and-reverse-engineering.md>here</a></p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//mbarak-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2020 -
2024
n1o_c0rTx
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5WLCXX3LGJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5WLCXX3LGJ")}</script></body></html>