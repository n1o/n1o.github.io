<!doctype html><html lang=en><head><title>2025 Year of Zig · Data Artificer and code:Breaker</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="n1o_c0rTx"><meta name=description content="
  Intro
  
    
    Link to heading
  

Programming languages come and go and during my 20 years of coding I have used many of them to at least some degree (more than just hello world). Thanks to ThePrimeagen I decided to take Zig for a spin. And boy I really like it! Just look at the mascot:

Come on, a crocodile with a jetpack? How cool is that?

  Why Zig
  
    
    Link to heading
  

Sure I would not invest a lot of time into anything that a full time YouTuber recommends. However, I was in search of a highly performant programming language that compiles to native code, has excellent C compatibility, and most importantly, is fun to write code in. If I look back at my past nearly 10 years, the most dominant languages I used were Python and Scala with a detour to Go, and some necessary evil of Javascript/Typescript (Thank god this was minimal). For a long time I thought Scala was the pinnacle of programming languages, it had everything: Classes, Traits, Pattern Matching, For Comprehension, Destructuring, Options, Eithers, Try, Monads, Monoids, EitherT, OptionT, Applicatives, Functors, Kleisli, &mldr;. And the list goes on nearly forever. I felt extremely smart writing Scala, however that was also its demise. You can take 2 people with the same experience, and their Scala code could look like two different programming languages. And that is a serious issue - the last thing you need is a language that takes forever to onboard a new person to, especially if this person is already experienced with the language. After 5 years of full time Scala development, I was competent and comfortable, but was well aware that there was a lot to the language I did not know, and this feeling of constantly chasing mastery felt not really rewarding."><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="2025 Year of Zig"><meta name=twitter:description content="Intro Link to heading Programming languages come and go and during my 20 years of coding I have used many of them to at least some degree (more than just hello world). Thanks to ThePrimeagen I decided to take Zig for a spin. And boy I really like it! Just look at the mascot:
Come on, a crocodile with a jetpack? How cool is that?
Why Zig Link to heading Sure I would not invest a lot of time into anything that a full time YouTuber recommends. However, I was in search of a highly performant programming language that compiles to native code, has excellent C compatibility, and most importantly, is fun to write code in. If I look back at my past nearly 10 years, the most dominant languages I used were Python and Scala with a detour to Go, and some necessary evil of Javascript/Typescript (Thank god this was minimal). For a long time I thought Scala was the pinnacle of programming languages, it had everything: Classes, Traits, Pattern Matching, For Comprehension, Destructuring, Options, Eithers, Try, Monads, Monoids, EitherT, OptionT, Applicatives, Functors, Kleisli, …. And the list goes on nearly forever. I felt extremely smart writing Scala, however that was also its demise. You can take 2 people with the same experience, and their Scala code could look like two different programming languages. And that is a serious issue - the last thing you need is a language that takes forever to onboard a new person to, especially if this person is already experienced with the language. After 5 years of full time Scala development, I was competent and comfortable, but was well aware that there was a lot to the language I did not know, and this feeling of constantly chasing mastery felt not really rewarding."><meta property="og:url" content="https://n1o.github.io/posts/2025-yearl-of-zig/"><meta property="og:site_name" content="Data Artificer and code:Breaker"><meta property="og:title" content="2025 Year of Zig"><meta property="og:description" content="Intro Link to heading Programming languages come and go and during my 20 years of coding I have used many of them to at least some degree (more than just hello world). Thanks to ThePrimeagen I decided to take Zig for a spin. And boy I really like it! Just look at the mascot:
Come on, a crocodile with a jetpack? How cool is that?
Why Zig Link to heading Sure I would not invest a lot of time into anything that a full time YouTuber recommends. However, I was in search of a highly performant programming language that compiles to native code, has excellent C compatibility, and most importantly, is fun to write code in. If I look back at my past nearly 10 years, the most dominant languages I used were Python and Scala with a detour to Go, and some necessary evil of Javascript/Typescript (Thank god this was minimal). For a long time I thought Scala was the pinnacle of programming languages, it had everything: Classes, Traits, Pattern Matching, For Comprehension, Destructuring, Options, Eithers, Try, Monads, Monoids, EitherT, OptionT, Applicatives, Functors, Kleisli, …. And the list goes on nearly forever. I felt extremely smart writing Scala, however that was also its demise. You can take 2 people with the same experience, and their Scala code could look like two different programming languages. And that is a serious issue - the last thing you need is a language that takes forever to onboard a new person to, especially if this person is already experienced with the language. After 5 years of full time Scala development, I was competent and comfortable, but was well aware that there was a lot to the language I did not know, and this feeling of constantly chasing mastery felt not really rewarding."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-20T08:31:40+01:00"><meta property="article:modified_time" content="2024-11-20T08:31:40+01:00"><meta property="article:tag" content="Zig"><link rel=canonical href=https://n1o.github.io/posts/2025-yearl-of-zig/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e927f7340e309d76dcb8fda85f1531ae7341aa9cd0b7f3ab77885dae77b1a0a2.css integrity="sha256-6Sf3NA4wnXbcuP2oXxUxrnNBqpzQt/Ord4hdrnexoKI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://n1o.github.io/>Data Artificer and code:Breaker
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Writing</a></li><li class=navigation-item><a class=navigation-link href=/awesome-t5/>Awesome T5</a></li><li class=navigation-item><a class=navigation-link href=/awesome-ssm/>Awesome SSM</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://n1o.github.io/posts/2025-yearl-of-zig/>2025 Year of Zig</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-11-20T08:31:40+01:00>November 20, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
11-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/zig/>Zig</a></span></div></div></header><div class=post-content><h1 id=intro>Intro
<a class=heading-link href=#intro><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Programming languages come and go and during my 20 years of coding I have used many of them to at least some degree (more than just hello world). Thanks to <a href=https://www.youtube.com/c/theprimeagen class=external-link target=_blank rel=noopener>ThePrimeagen</a> I decided to take <a href=https://ziglang.org/ class=external-link target=_blank rel=noopener>Zig</a> for a spin. And boy I really like it! Just look at the mascot:</p><p><img src=/images/zero.svg></p><p>Come on, a crocodile with a jetpack? How cool is that?</p><h1 id=why-zig>Why Zig
<a class=heading-link href=#why-zig><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Sure I would not invest a lot of time into anything that a full time YouTuber recommends. However, I was in search of a highly performant programming language that compiles to native code, has excellent C compatibility, and most importantly, is fun to write code in. If I look back at my past nearly 10 years, the most dominant languages I used were Python and Scala with a detour to Go, and some necessary evil of Javascript/Typescript (Thank god this was minimal). For a long time I thought Scala was the pinnacle of programming languages, it had everything: Classes, Traits, Pattern Matching, For Comprehension, Destructuring, Options, Eithers, Try, Monads, Monoids, EitherT, OptionT, Applicatives, Functors, Kleisli, &mldr;. And the list goes on nearly forever. I felt extremely smart writing Scala, however that was also its demise. You can take 2 people with the same experience, and their Scala code could look like two different programming languages. And that is a serious issue - the last thing you need is a language that takes forever to onboard a new person to, especially if this person is already experienced with the language. After 5 years of full time Scala development, I was competent and comfortable, but was well aware that there was a lot to the language I did not know, and this feeling of constantly chasing mastery felt not really rewarding.</p><p>At some point I started to learn Go, which has a totally different philosophy compared to Scala - it is minimal and simple. I was able to learn the language, sure not master it, but I was able to somewhat efficiently use channels and structure my code nicely in a couple of days, and ship something to production not long after that. That was the point when I was sure I would never go back to Scala again.</p><p>Zig is actually very similar to Go. It is a simple language, ultimately fun to write in, and what&rsquo;s best, it is extremely performant.</p><h1 id=little-tour-of-zig>Little Tour of Zig
<a class=heading-link href=#little-tour-of-zig><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Let&rsquo;s look at a for loop in Zig,</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> array = [_]<span style=color:#fff;font-weight:700>u32</span>{ <span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>3</span> };
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> (array) |elem| {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>You also want to have the index of the array? Sure, here it is:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> (array, <span style=color:#ff0;font-weight:700>0</span>..) |elem, index| {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Your code can have exceptions? Sure, we have values as errors:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>fn</span> divide(q: <span style=color:#fff;font-weight:700>u32</span>, d:<span style=color:#fff;font-weight:700>u32</span>) <span style=color:#fff;font-weight:700>error</span>{ZeroDivision}!<span style=color:#fff;font-weight:700>u32</span> {
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>if</span> (d == <span style=color:#ff0;font-weight:700>0</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>error</span>.ZeroDivision;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>return</span> q/d;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> result = divide(<span style=color:#ff0;font-weight:700>10</span>, <span style=color:#ff0;font-weight:700>0</span>) <span style=color:#fff;font-weight:700>catch</span> |err| {
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// OOPS ERROR
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>return</span> ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// OR better we can let it crash
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> result = <span style=color:#fff;font-weight:700>try</span> divide(<span style=color:#ff0;font-weight:700>10</span>,<span style=color:#ff0;font-weight:700>0</span>);
</span></span></code></pre></div><p>What about Null? Well, we have Optional, with syntactic sugar for default cases:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> x: ?<span style=color:#fff;font-weight:700>f32</span> = <span style=color:#fff;font-weight:700>null</span>;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> y = a <span style=color:#fff;font-weight:700>orelse</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span></code></pre></div><p>What if this optional is actually needed? Well, we can let it crash:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> a: ?<span style=color:#fff;font-weight:700>f32</span> = <span style=color:#ff0;font-weight:700>5</span>;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> b = a <span style=color:#fff;font-weight:700>orelse</span> <span style=color:#fff;font-weight:700>unreachable</span>;
</span></span></code></pre></div><p>Unreachable tells the compiler to crash the program if we take an unreachable branch.</p><h2 id=safety>Safety
<a class=heading-link href=#safety><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Zig is a modern systems programming language, and since C++ is unsafe to use (especially by minors), it is important that the language provides features that ensure memory safety! Go achieves this by being garbage collected, while Rust uses the borrow checker and lifetimes.</p><h3 id=allocators>Allocators
<a class=heading-link href=#allocators><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>By default, if you define any variable in Zig it always lives on the Stack, however this may be limited - we can put things on the stack only if we know their size at compile time! To have objects that can dynamically grow, we have to put them on the Heap. To do this Zig provides allocators:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>fn</span> some_function() !<span style=color:#fff;font-weight:700>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>var</span> gpa = std.heap.GeneralPurposeAllocator(.{}){};
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> allocator = gpa.allocator();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>defer</span> {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>const</span> deinit_status = gpa.deinit();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> (deinit_status == .leak) expect(<span style=color:#fff;font-weight:700>false</span>) <span style=color:#fff;font-weight:700>catch</span> <span style=color:#fff;font-weight:700>@panic</span>(<span style=color:#0ff;font-weight:700>&#34;I leaked memory&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>var</span> list = ArrayList(<span style=color:#fff;font-weight:700>u8</span>).init(allocator);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>defer</span> list.deinit();
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>try</span> list.append(<span style=color:#0ff;font-weight:700>&#39;H&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>try</span> list.append(<span style=color:#0ff;font-weight:700>&#39;e&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>try</span> list.append(<span style=color:#0ff;font-weight:700>&#39;l&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>try</span> list.append(<span style=color:#0ff;font-weight:700>&#39;l&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>try</span> list.append(<span style=color:#0ff;font-weight:700>&#39;o&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>try</span> list.appendSlice(<span style=color:#0ff;font-weight:700>&#34; World!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here are 2 important parts to understand:</p><ol><li>Use of defer keyword, which delays the execution of a block or function when the variable (block) leaves the scope. This sounds complicated - we can imagine that defer automatically moves the statement to the bottom of the function, so they are executed before the function ends regardless of where we define it!</li><li>Objects that leverage the heap always take an allocator, this follows the &ldquo;no hidden allocations&rdquo; philosophy of Zig, making heap use explicit (and also easy to audit).</li></ol><p>If we would compare this to Rust, if we want to define something on the heap we can use:</p><ol><li>Rc, this is reference counting, and it is equivalent to shared_ptr of C++, for data that can be shared</li><li>Arc, this is equivalent to unique_ptr of C++, this is for data that cannot be shared, has to have exactly one owner</li><li>Box, this will just put the object on the heap and the same ownership rules apply as to stack variables, where we can have exactly one mutable access and unlimited readonly const</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#fff;font-weight:700>let</span> my_box = <span style=color:#fff;font-weight:700>Box</span>::new(<span style=color:#ff0;font-weight:700>1</span>); 
</span></span></code></pre></div><p>So this will put the 1 on the heap and then the compiler is responsible to release the memory when my_box leaves the scope, if we look at the definition of Box:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#fff;font-weight:700>pub</span> <span style=color:#fff;font-weight:700>struct</span> <span style=color:#fff;font-weight:700>Box</span>&lt;T, A = Global&gt;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>where</span>
</span></span><span style=display:flex><span>    A: Allocator,
</span></span><span style=display:flex><span>    T: ?<span style=color:#fff;font-weight:700>Sized</span>;
</span></span></code></pre></div><p>We can see that Rust also has Allocators however they are implicit, this makes it less straightforward what object goes on the heap and what is on the stack, and the problem becomes even more obvious for the infamous str vs String:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#fff;font-weight:700>let</span> hello_world = <span style=color:#0ff;font-weight:700>&#34;Hello, World!&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>let</span> hello = <span style=color:#fff;font-weight:700>String</span>::from(<span style=color:#0ff;font-weight:700>&#34;Hello, world!&#34;</span>);
</span></span></code></pre></div><p>The first lives on the stack, and the second lives on a heap. Again this is something one will learn with time, but it is an implicit behavior making the language more complex.</p><h3 id=arrays-slices-and-sentinels>Arrays, Slices and Sentinels
<a class=heading-link href=#arrays-slices-and-sentinels><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>If you ever wrote some C program, there is a good chance that you wrote it vulnerable. Why? Well by default C strings are null terminated, which means the length of a string is not really known, and it is extremely easy to leak data that we should not! Zig has two concepts that make things a bit more safe:</p><h4 id=arrays-and-slices>Arrays and Slices
<a class=heading-link href=#arrays-and-slices><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>Here we require that the arrays have a known size, and we are not really allowed to go beyond this size, otherwise we get an exception:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> a = [_]<span style=color:#fff;font-weight:700>u8</span>{ <span style=color:#0ff;font-weight:700>&#39;h&#39;</span>, <span style=color:#0ff;font-weight:700>&#39;e&#39;</span>, <span style=color:#0ff;font-weight:700>&#39;l&#39;</span>, <span style=color:#0ff;font-weight:700>&#39;l&#39;</span>, <span style=color:#0ff;font-weight:700>&#39;o&#39;</span> }; <span style=color:#007f7f>// this will end up as [5]u8
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>const</span> slice = a[<span style=color:#ff0;font-weight:700>0</span>..<span style=color:#ff0;font-weight:700>3</span>];
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> slice_to_te_end = a[<span style=color:#ff0;font-weight:700>0</span>..];
</span></span><span style=display:flex><span>a[<span style=color:#ff0;font-weight:700>4</span>] <span style=color:#007f7f>// this blows up, this is an off by one error 
</span></span></span></code></pre></div><h4 id=sentinels>Sentinels
<a class=heading-link href=#sentinels><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>Using sentinels we can &ldquo;extend&rdquo; array by an extra value:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> ar = [_:<span style=color:#ff0;font-weight:700>0</span>]<span style=color:#fff;font-weight:700>u32</span>{ <span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span> };
</span></span><span style=display:flex><span>assert(ar[<span style=color:#ff0;font-weight:700>2</span>] == <span style=color:#ff0;font-weight:700>0</span>); <span style=color:#007f7f>// this is actually of by one but we get 0 since it is a sentinel
</span></span></span></code></pre></div><h2 id=c-interop>C Interop
<a class=heading-link href=#c-interop><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>So you want some C code in your Zig project? Here is how you do it:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> elf = <span style=color:#fff;font-weight:700>@cImport</span>({
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>@cInclude</span>(<span style=color:#0ff;font-weight:700>&#34;elf.h&#34;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Yep, @cImport and you are good to go, you can use functions and structs from in our case <code>elf.h</code> and you would use them like any other struct or function from Zig.</p><h2 id=comptime>Comptime
<a class=heading-link href=#comptime><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>This is an extremely useful feature, which allows executing Zig during compilation to modify the source code itself:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>pub</span> <span style=color:#fff;font-weight:700>fn</span> ElfFile(<span style=color:#fff;font-weight:700>comptime</span> T: <span style=color:#fff;font-weight:700>type</span>) <span style=color:#fff;font-weight:700>type</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> is64Bit = <span style=color:#fff;font-weight:700>comptime</span> (<span style=color:#fff;font-weight:700>@typeName</span>(T) == <span style=color:#fff;font-weight:700>@typeName</span>(elf.Elf64_Ehdr));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> S: <span style=color:#fff;font-weight:700>type</span> = <span style=color:#fff;font-weight:700>comptime</span> <span style=color:#fff;font-weight:700>switch</span> (<span style=color:#fff;font-weight:700>@typeName</span>(T)) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>@typeName</span>(elf.Elf64_Ehdr) =&gt; elf.Elf64_Shdr,
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>@typeName</span>(elf.Elf32_Ehdr) =&gt; elf.Elf32_Shdr,
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span> =&gt; <span style=color:#fff;font-weight:700>unreachable</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> P: <span style=color:#fff;font-weight:700>type</span> = <span style=color:#fff;font-weight:700>comptime</span> <span style=color:#fff;font-weight:700>switch</span> (<span style=color:#fff;font-weight:700>@typeName</span>(T)) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>@typeName</span>(elf.Elf64_Ehdr) =&gt; elf.Elf64_Phdr,
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>@typeName</span>(elf.Elf32_Ehdr) =&gt; elf.Elf32_Phdr,
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span> =&gt; <span style=color:#fff;font-weight:700>unreachable</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The snippet above is from an ElfFile reader that I am writing for my <a href=https://codebreakers.re/courses class=external-link target=_blank rel=noopener>Dissecting Binaries</a> course. It is actually used as:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> ElfReader = <span style=color:#fff;font-weight:700>union</span>(<span style=color:#fff;font-weight:700>enum</span>) {
</span></span><span style=display:flex><span>    bit32: ElfFile(elf.Elf32_Ehdr),
</span></span><span style=display:flex><span>    bit64: ElfFile(elf.Elf64_Ehdr),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>pub</span> <span style=color:#fff;font-weight:700>fn</span> free(self: ElfReader) <span style=color:#fff;font-weight:700>void</span> {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>switch</span> (self) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>inline</span> <span style=color:#fff;font-weight:700>else</span> =&gt; |case| <span style=color:#fff;font-weight:700>return</span> case.free(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>pub</span> <span style=color:#fff;font-weight:700>fn</span> print_header(self: ElfReader) <span style=color:#fff;font-weight:700>void</span> {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>switch</span> (self) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>inline</span> <span style=color:#fff;font-weight:700>else</span> =&gt; |case| <span style=color:#fff;font-weight:700>return</span> case.print_header(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>const</span> res: ElfReader = blk: {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>switch</span> (e_ident[elf.EI_CLASS]) {
</span></span><span style=display:flex><span>        elf.ELFCLASS64 =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>const</span> bit64 = <span style=color:#fff;font-weight:700>try</span> ElfFile(elf.Elf64_Ehdr).init(file, allocator);
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>break</span> :blk ElfReader{ .bit64 = bit64 };
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        elf.ELFCLASS32 =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>const</span> bit32 = <span style=color:#fff;font-weight:700>try</span> ElfFile(elf.Elf32_Ehdr).init(file, allocator);
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>break</span> :blk ElfReader{ .bit32 = bit32 };
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span> =&gt; <span style=color:#fff;font-weight:700>unreachable</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This is a long example, however it shows the power of comptime, which replaces generics and macros with just Zig! I remember trying to learn <a href=https://docs.scala-lang.org/overviews/macros/overview.html class=external-link target=_blank rel=noopener>Scala Macros</a>. While I understand that macros operate on the AST of the language, you still end up with an extra language embedded within a language.</p><h2 id=recap>Recap
<a class=heading-link href=#recap><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>There are other language features I did not include, like Structs, Enums, Unions, &mldr;, but they are nothing you have not seen in other languages. As I mentioned at the beginning, when you write Zig it feels very much like Go, but without garbage collection. If you add nice error handling, options instead of Nil, and Allocators for explicit memory management you end up with a language that is meant to be used not just in 2025, but also in many years to come. And on top of it, when you write Zig, you feel joy, which is really uncommon in programming languages lately (Especially Rust or TypeScript).</p><h1 id=why-zig-when-there-is-rust>Why Zig when there is Rust?
<a class=heading-link href=#why-zig-when-there-is-rust><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>I guess you saw this coming. I have had a crush on Rust since 2014, however it never really took off. I did a couple of side projects, but I never really shipped anything to production. On paper Rust is the perfect language for me, it shares a lot of features with Scala, at least from the perspective of the type system and syntax. However, similarly to Scala, I always felt that Rust has just too many features, and I really need something that forces me to express what I want as simply as possible, but not too simple.</p><p>But there is more, I honestly believe that a systems programming language should not have automatic memory management. Why? There are multiple reasons. First, I believe that manual memory management is the key to unlock extra performance, and an example is the following <a href="https://www.youtube.com/watch?v=SR2LRhnL1AQ&amp;t=69s&amp;pp=ygUNemlnIGJlbmNobWFyaw%3D%3D" class=external-link target=_blank rel=noopener>Zig vs Rust</a> benchmark. Sure benchmarks are a lie, and I do not trust them even if they come from a third party. But since Zig is more low level than Rust, it gives you more control over your hardware, squeezing out some extra performance.</p><p>The explicit use of Allocators gives me the possibility of implementing the following <a href=https://arxiv.org/pdf/2410.17928 class=external-link target=_blank rel=noopener>SJMalloc</a> allocator in Zig. Sure, I can do it for Rust as well, but then I have to find all the possible places which use an Allocator that are not explicitly defined, making it hard to integrate into an existing project.</p><p>And lastly, and probably the most important part for me, I am leveraging a lot of existing C libraries. For example, I am building a Fuzzer on top of QEMU. This is already done in <a href=https://www.s3.eurecom.fr/docs/bar24_malmain.pdf class=external-link target=_blank rel=noopener>Rust LibAFL QEMU</a>, however if you look at the code, you quickly realize that the authors had to first fork QEMU and implement extra features. Second, they needed to generate Rust bindings for the C code, and since QEMU is not really Rust, they extensively use unsafe.</p><p>To recap, yes Rust is amazing when you stay in Rust, and there are a lot of things where the extra safety that Rust gives you is crucial. For example, SSL libraries or any library or service that is directly exposed to the internet, where any malicious use can have huge impact, should probably use Rust. But for the rest, there is Go, yes Go - this is not a typo, I wrote and meant Go! Zig is really perfect if you need to integrate with existing C libraries and when you need to squeeze out every last drop of performance from your hardware. (Sure there is high-performance Rust, but that&rsquo;s another story, making Rust a whole different language, once again!). But most Web APIs, CLI tools can run for a couple of milliseconds longer, consuming extra couple of bytes memory.</p><h2 id=is-there-more>Is there More?
<a class=heading-link href=#is-there-more><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Sure, Zig is an amazing build system, it can be used to build C/C++ projects and it supports cross compilation, which means you can emit for example ARM64 code on your x86 Linux Machine. Cross compilation makes it especially compelling for tools like <a href=https://bun.sh/ class=external-link target=_blank rel=noopener>Bun</a> and look up this <a href="https://www.youtube.com/watch?v=yJmyYosyDDM&amp;t=459s&amp;pp=ygULYnVuIHZzIGRlbm8%3D" class=external-link target=_blank rel=noopener>Bun vs Deno</a> benchmark, yes I know, benchmarks lie!</p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//mbarak-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2020 -
2024
n1o_c0rTx
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5WLCXX3LGJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5WLCXX3LGJ")}</script></body></html>